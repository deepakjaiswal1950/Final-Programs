package Math;

import java.util.*;
/*
Convert it into a decimal.
If the fractional part is repeating, enclose the repeating part in parentheses.
 */
/*
// THIS CODE IS ONLY VALID FOR ONE REPEATED DIGIT, BUT NOT FOR MULTIPLE DIGITS
public class A_Simple_Fraction {
    public static void main(String[] args) {

        double nr = 1;
        double dr = 3;

        double tmp = nr/dr; //0.23444;
        //System.out.println(tmp);

        String str = String.valueOf(tmp);
        //System.out.println(str);

        int i=0, n = str.length()-1;

        String ans = "";
        while(str.charAt(i) != '.'){
            ans += str.charAt(i++);
        }

        for(int j = i;j<n;j++){
            if(str.charAt(j) != str.charAt(j+1)){
                ans += str.charAt(j);
            }else{
                ans += '(';
                ans += str.charAt(j);
                ans += ')';
                break;
            }
        }
        System.out.println(ans);
    }
}
 */


public class A_Simple_Fraction {
/*
Approach: The idea is to first calculate the integral quotient (absolute part before
decimal point) and then calculate the fractional part. To check if the fractional part
is repeating, insert the remainder (numerator % denominator) in a map with key as remainder
and value as the index position at which this remainder occurs. If at any point of time,
the remainder becomes zero, then there doesnâ€™t exist a repeating fraction otherwise if
the remainder is already found in the map, then there exists a repeating fraction.
 */
    public static String calculateFraction(int num, int den) {
        if (num == 0)
            return "0"; // if numerator is zero
        if (den == 0)
            return ""; // if denominator is zero

        // result StringBuilder

        StringBuilder result = new StringBuilder();
        if ((num < 0) ^ (den < 0))
            result.append("-"); // check -ve sign

        // absoulte values of num and den

        num = Math.abs(num);
        den = Math.abs(den);

        long quo = num / den; // Quotient
        long rem = num % den * 10; // calculating remainder

        result.append(
                String.valueOf(quo)); // appending quotient
        if (rem == 0)
            return result
                    .toString(); // return if remainder is 0

        // if remainder is not zero, continue

        result.append(".");
        Map<Long, Integer> m
                = new HashMap<>(); // map for storing remainder
        // and the indexes of the appropriate decimal in stringbuilder

        while (rem != 0) {

            if (m.containsKey(rem)) {

                // if the rem is already present, find the
                // index and append ( )

                int index = m.get(rem);
                String part1 = result.substring(0, index);
                String part2 = "("
                        + result.substring(
                        index, result.length())
                        + ")";
                return part1 + part2;
            }

            // continue updating the map and appending quo
            // which was generated by dividing rem with den

            m.put(rem, result.length());
            quo = rem / den;
            result.append(String.valueOf(quo));

            // update rem
            rem = (rem % den) * 10;
        }
        return result.toString();
    }

    public static void main(String[] args) {

        int nr = 50;
        int dr = 22;

        System.out.println(calculateFraction(nr,dr));

    }
}
